# Service 详解

---

> Service 是一种程序后台运行的方案,用于不需要用户交互,长期运行的任务，Service 并不是在单独进程中运行,也是运行在应用程序进程的主线程中,在执行具体耗时任务过程中要手动开启子线程,应用程序进程被杀死,所有依赖该进程的服务也会停止运行

## 目录

-[生命周期](#生命周期)

-[启动方式](#启动方式)

-[Service 通信](#Service通信)

-[IntentService](#IntentService)

-[ForegroundService](#ForegroundService)

## 生命周期

Service 有两种启动服务的方式，对应的生命周期也不一致

![Service生命周期](/Resource/Image/service_lifecycle.png)

**onCreate**
首次创建服务时，系统将调用此方法。如果服务已在运行，则不会调用此方法，该方法只调用一次

**onStartCommand**
当另一个组件通过调用 startService()请求启动服务时，系统将调用此方法

**onDestroy**
当服务不再使用且将被销毁时，系统将调用此方法

**onBind**
当另一个组件通过调用 bindService()与服务绑定时，系统将调用此方法

**onUnbind**
当另一个组件通过调用 unbindService()与服务解绑时，系统将调用此方法

**onRebind**
当旧的组件与服务解绑后，另一个新的组件与服务绑定，onUnbind()返回 true 时，系统将调用此方法

## 启动方式

通过上面的生命周期我们可知道，启动 Service 的方式有两种分别是 startService 和 bindService，接下来我们来分别介绍一下

###### startService

1.在 AndroidManifest.xml 注册我们所要写的 Service，我们这里以 AService 为例

```
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.madreain"
    >

    ……

        <service android:name="com.madreain.AService" >
        </service>
    </application>

</manifest>
```

2.AService 继承 Service 的相关代码

```
public class AService extends Service{

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}
```

我们还可以在相关的生命周期中打印 Thread.currentThread().getId(）及其相关值

3.在 MainActivity 中使用开启服务

```
Intent intent = new Intent(this, AService.class);
startService(intent);

```

4.多次调用 Service 来观察生命周期

```
//启动三个相同服务
Intent intent1 = new Intent(this, AService.class);
startService(intent1);

Intent intent2 = new Intent(this, AService.class);
startService(intent2);

Intent intent3 = new Intent(this, AService.class);
startService(intent3);

//停止服务
Intent intent4 = new Intent(this, AService.class);
stopService(intent4);

//再启动服务
Intent intent5 = new Intent(this, AService.class);
startService(intent5);

```

这时候我们可以在 Aservice 不同生命周期中打印生命周期执行函数及其 Thread ID 来分析得出：
1.Thread ID 打印出来是相同的，说明回调方法都在主线程执行的 2.多次调用 startService，onCreate 方法只被执行一次，每启动一次触发一次 onStartCommand,多次 startService 不会重复执行 onCreate 回调，但每次都会执行 onStartCommand 回调。

###### bindService

1.创建 BService

```
public class BService extends Service{

    //client 可以通过Binder获取Service实例
    public class MyBinder extends Binder {
        public BService getService() {
            return BService.this;
        }
    }

    //通过binder实现调用者client与Service之间的通信
    private MyBinder binder = new MyBinder();

    private final Random generator = new Random();

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return START_NOT_STICKY;
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }

    @Override
    public boolean onUnbind(Intent intent) {
        return false;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }

    //getRandomNumber是Service暴露出去供client调用的公共方法
    public int getRandomNumber() {
        return generator.nextInt();
    }
}
```

2.在 BActivity 中使用

```
public class BActivity extends Activity implements Button.OnClickListener {

    private BService service = null;

    private boolean isBind = false;

    private ServiceConnection conn = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            isBind = true;
            BService.MyBinder myBinder = (BService.MyBinder)binder;
            service = myBinder.getService();
            //int num = service.getRandomNumber();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            isBind = false;
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_b);

        findViewById(R.id.btnBindService).setOnClickListener(this);
        findViewById(R.id.btnUnbindService).setOnClickListener(this);
        findViewById(R.id.btnFinish).setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        if(v.getId() == R.id.btnBindService){
            //单击了“bindService”按钮
            Intent intent = new Intent(this, TestTwoService.class);
            intent.putExtra("from", "ActivityB");
            bindService(intent, conn, BIND_AUTO_CREATE);
        }else if(v.getId() == R.id.btnUnbindService){
            //单击了“unbindService”按钮
            if(isBind){
                unbindService(conn);
            }
        }else if(v.getId() == R.id.btnFinish){
            //单击了“Finish”按钮
            this.finish();
        }
    }
    @Override
    public void onDestroy(){
        super.onDestroy();
    }
}
```

再创建一个相同的 CActivity 去绑定 Service,然后我们去动手执行一下操作，然后在对应的生命周期中打印生命周期执行的方法以及 onServiceConnected 方法中打印调用情况
1.BActivity 去 bindService
2.CActivity 去 bindService
3.CActivity 中的 unbindService 按钮
4.BActivity 中的 unbindService 按钮

上面四种情况去操作可发现： 1.再次创建不会调用 onCreate、onBind 方法 2.只有都调用了 unbindService，BService 才会去执行 onUnbind 方法，再执行 onDestroy

补充：系统资源回收

```
public int onStartCommand(Intent intent, int flags, int startId) {
  return START_NOT_STICKY | START_STICKY | START_REDELIVER_INTENT;
}
```

START_NOT_STICKY
当系统因回收资源而销毁了 Service，当资源再次充足时不再自动启动 Service，除非有未处理的 Intent 准备发送。

START_STICKY
当系统因回收资源而销毁了 Service，当资源再次充足时自动启动 Service。而且再次调用 onStartCommand() 方法，但是不会传递最后一次的 Intent，相反系统在回调 onStartCommand() 的时候会传一个空 Intent，除非有未处理的 Intent 准备发送。

START_REDELIVER_INTENT
当系统因回收资源而销毁了 Service，当资源再次充足时自动启动 Service，并且再次调用 onStartCommand() 方法，并会把最后一次 Intent 再次传递给 onStartCommand()，相应的在队列里的 Intent 也会按次序一次传递。此模式适用于下载等服务。

## Service 通信

Activity 与 Service 进行通信有三种方式

######通过 Intent 传递参数

在 MainActivity 中传递参数

```
intent = new Intent(MainActivity.this, MyService.class);  
intent.putExtra("data", object);
startService(intent);
```

在MyService的onStartCommand接受参数
```
@Override  
public int onStartCommand(final Intent intent, int flags, int startId) {  
    data = intent.getStringExtra("data");  
    return super.onStartCommand(intent, flags, startId);  
}  

```

######Binder类

MyService 中我们创建一个Binder类，让其实现android.os.Binder类，并且定义一个方法setData，然后我们通过onBind（）方法将其对象返回MainActivity。

设置MyService中设置参数数据的方法
```
public class MyService extends Service {  
    private String data;  
    public MyService() {  
    }  
  
    @Override  
    public IBinder onBind(Intent intent) {  
       return new Binder();  
    }  
  
    public class Binder extends android.os.Binder{  
        public void setData(String data){  
            MyService.this.data = data;  
        }  
    }  
    @Override  
    public void onCreate() {  
        super.onCreate();  
    }  
  
    @Override  
    public void onDestroy() {  
        super.onDestroy();  
    }  
    @Override  
    public boolean onUnbind(Intent intent) {  
        return super.onUnbind(intent);  
    }  
  
}  
```

在MainActivity中实现ServiceConnection方法，获取到MyService中返回的Binder对象，接着我们通过Binder对象调用它的方法setData向其传递数据

```
public class MainActivity extends AppCompatActivity implements View.OnClickListener, ServiceConnection {  
  
    private Intent intent;  
    private MyService.Binder myBinder = null;//①  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        intent = new Intent(MainActivity.this, MyService.class);  
        findViewById(R.id.btySend).setOnClickListener(this);  
  
    }  
  
    @Override  
    public void onClick(View view) {  
        switch (view.getId()) {  
            case R.id.btySend://想MyService传递数据  
                if (myBinder != null) {  
                    myBinder.setData("传递能想传递的数据");//③  
                }  
                break;
            default:
                break;      
        }  
    }  
    //一旦绑定成功就会执行该函数  
    @Override  
    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {  
        myBinder = (MyService.Binder) iBinder;//②  
    }  
  
    @Override  
    public void onServiceDisconnected(ComponentName componentName) {  
  
    }  
  
}  

```
注意①②③的顺序


######broadcast

通过广播的的形式，可参考[BroadcastReciver详解](10004-BroadcastReciver详解.md)


## IntentService

## ForegroundService
